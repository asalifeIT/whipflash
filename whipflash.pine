// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © eylwithsteph
// This is a study to determine if small candles bodies (little difference between open and close) regardless of overall candle length (high/low)
// can be used to filter choppy markets. The indicator will calculate the selected average "MA Mode" of (close-open). To standardize this result
// and ensure any filters/thresholds do not need to be recalculated for each instrument the result will be used to calculate the Z Score. 
// The idea is that when candle bodies are small there is very little actual price movement, and therefore price is choppy. When considering the
// Z Score of that result, any outliers ie larger candle bodies, could show a potential trend forming. This indicator is similar to QStick but
// allows more customization by the user
// Multiple MA Options Credits to @Fractured
// Bits and Pieces from @AlexGrover, @Montyjus, and @Jiehonglim 
// As always, trade at your own risk. 
//@version=4
study("Whiplash - Enhanced Signals", shorttitle="Whiplash")

PriceSmoothing = input(15, title="Price Smoothing")

Mode = input(title = "MA Mode", defval="SMMA", options=["TMA","ALMA", "EMA", "DEMA", "TEMA", "WMA", "VWMA", "SMA", "SMMA", "HMA", "LSMA", "JMA", "VAMA", "FRAMA", "ZLEMA", "KAMA", "Kijun", "Kijun v2", "McGinley", "IDWMA", "FLMSA", "PEMA", "HCF", "TIF", "MF", "ARMA", "DAF","WRMA", "RMA", "RAF", "GF", "A2RMA", "EDSMA"])

vq0_th = input(1.68, title="Threshold 1")
vq0_th2 = input(1.96, title="Threshold 2")
vq0_th3 = input(2.58, title="Threshold 3")

vq0_mid = 0
zlength = 100
    
lsma_offset  = 0
alma_offset  = 0.85
alma_sigma   = 6
jurik_phase = 50
jurik_power = 2
volatility_lookback = 51
frama_FC = 1
frama_SC = 200
kama_fast_len = 2
kama_slow_len = 30
center = 10

//MF
beta = 0.8
feedback = false
z = 0.5
//ARMA
gamma = 3
zl = false

//GF
zeta = 1

//EDSMA
ssfLength = 20
ssfPoles = 2

//IDWMA
calcWeight(src, length, i) =>
    distanceSum = 0.0
    for j = 0 to length - 1
        distanceSum := distanceSum + abs(nz(src[i]) - nz(src[j]))
    distanceSum

//HCF
//study("Hybrid Convolution Filter",overlay=true)
//length = input(14)
//----
f(x) => 
    .5*(1 - cos(x*3.14159))

d(x,length) => 
    f(x/length) - f((x-1)/length)
//----
filter(a,b,length) =>
    sum = 0.
    for i = 1 to length
        sgn = f(i/length)
        sum := sum + (sgn*b + (1 - sgn)*a[i-1]) * d(i,length)
    sum
//----

//A2RMA
ama(er,x)=>
    a = 0.
    a := er*x+(1-er)*nz(a[1],x)


//EDSMA
get2PoleSSF(src, length) =>
    PI = 2 * asin(1)
    arg = sqrt(2) * PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(arg)
    c2 = b1
    c3 = -pow(a1, 2)
    c1 = 1 - c2 - c3
    
    ssf = 0.0
    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])

get3PoleSSF(src, length) =>
    PI = 2 * asin(1)

    arg = PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(1.738 * arg)
    c1 = pow(a1, 2)

    coef2 = b1 + c1
    coef3 = -(c1 + b1 * c1)
    coef4 = pow(c1, 2)
    coef1 = 1 - coef2 - coef3 - coef4

    ssf = 0.0
    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])


ma(type, src, len) =>
    float result = 0
    if type=="TMA"
        result := sma(sma(src, ceil(len / 2)), floor(len / 2) + 1)
    if type=="SMA" // Simple
        result := sma(src, len)
    if type=="EMA" // Exponential
        result := ema(src, len)
    if type=="DEMA" // Double Exponential
        e = ema(src, len)
        result := 2 * e - ema(e, len)
    if type=="TEMA" // Triple Exponential
        e = ema(src, len)
        result := 3 * (e - ema(e, len)) + ema(ema(e, len), len)
    if type=="WMA" // Weighted
        result := wma(src, len)
    if type=="VWMA" // Volume Weighted
        result := vwma(src, len) 
    if type=="SMMA" // Smoothed
        w = wma(src, len)
        result := na(w[1]) ? sma(src, len) : (w[1] * (len - 1) + src) / len
    if type=="HMA" // Hull
        result := wma(2 * wma(src, len / 2) - wma(src, len), round(sqrt(len)))
    if type=="LSMA" // Least Squares
        result := linreg(src, len, lsma_offset)
    if type=="ALMA" // Arnaud Legoux
        result := alma(src, len, alma_offset, alma_sigma)
    if type=="JMA" // Jurik
        /// Copyright © 2018 Alex Orekhov (everget)
        /// Copyright © 2017 Jurik Research and Consulting.
        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase / 100 + 1.5
        beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
        alpha = pow(beta, jurik_power)
        jma = 0.0
        e0 = 0.0
        e0 := (1 - alpha) * src + alpha * nz(e0[1])
        e1 = 0.0
        e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])
        e2 = 0.0
        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * pow(1 - alpha, 2) + pow(alpha, 2) * nz(e2[1])
        jma := e2 + nz(jma[1])
        result := jma
    if type=="VAMA" // Volatility Adjusted
        /// Copyright © 2019 to present, Joris Duyck (JD)
        mid=ema(src,len)
        dev=src-mid
        vol_up=highest(dev,volatility_lookback)
        vol_down=lowest(dev,volatility_lookback)
        result := mid+avg(vol_up,vol_down)
    if type=="FRAMA" // Fractal Adaptive
        int len1 = len/2
        e = 2.7182818284590452353602874713527
        w = log(2/(frama_SC+1)) / log(e) // Natural logarithm (ln(2/(SC+1))) workaround
        H1 = highest(high,len1)
        L1 = lowest(low,len1)
        N1 = (H1-L1)/len1
        H2_ = highest(high,len1)
        H2 = H2_[len1]
        L2_ = lowest(low,len1)
        L2 = L2_[len1]
        N2 = (H2-L2)/len1
        H3 = highest(high,len)
        L3 = lowest(low,len)
        N3 = (H3-L3)/len
        dimen1 = (log(N1+N2)-log(N3))/log(2)
        dimen = iff(N1>0 and N2>0 and N3>0,dimen1,nz(dimen1[1]))
        alpha1 = exp(w*(dimen-1))
        oldalpha = alpha1>1?1:(alpha1<0.01?0.01:alpha1)
        oldN = (2-oldalpha)/oldalpha
        N = (((frama_SC-frama_FC)*(oldN-1))/(frama_SC-1))+frama_FC
        alpha_ = 2/(N+1)
        alpha = alpha_<2/(frama_SC+1)?2/(frama_SC+1):(alpha_>1?1:alpha_)
        frama = 0.0
        frama :=(1-alpha)*nz(frama[1]) + alpha*src
        result := frama
    if type=="ZLEMA" // Zero-Lag EMA
        f_lag = (len - 1) / 2
        f_data = src + (src - src[f_lag])
        result := ema(f_data, len)
    if type=="KAMA" // Kaufman Adaptive
        mom = abs(change(src, len))
        volatility = sum(abs(change(src)), len)
        er = volatility != 0 ? mom / volatility : 0
        fastAlpha = 2 / (kama_fast_len + 1)
        slowAlpha = 2 / (kama_slow_len + 1)
        sc = pow((er * (fastAlpha - slowAlpha)) + slowAlpha, 2)
        kama = 0.0
        kama := sc * src + (1 - sc) * nz(kama[1])
        result := kama
    if type=="Kijun" //Kijun-sen
        kijun = avg(lowest(len), highest(len))
        result :=kijun
    if type=="Kijun v2"
        kijun = avg(lowest(len), highest(len))
        conversionLine = avg(lowest(len/2), highest(len/2))
        delta = (kijun + conversionLine)/2
        result :=delta
    if type=="McGinley"
        mg = 0.0
        mg := na(mg[1]) ? ema(src, len) : mg[1] + (src - mg[1]) / (len * pow(src/mg[1], 4))
        result :=mg
    if type=="IDWMA"
        sum = 0.0
        weightSum = 0.0
        for i = 0 to len - 1
            weight = calcWeight(src, len, i)
            sum := sum + nz(src[i]) * weight
            weightSum := weightSum + weight
        idwma = sum / weightSum
        result := idwma
    if type=="FLMSA"
        n = bar_index
        b = 0.
        e = sma(abs(src - nz(b[1])),len)
        z = sma(src - nz(b[1],src),len)/e 
        r = (exp(2*z) - 1)/(exp(2*z) + 1) 
        a = (n - sma(n,len))/stdev(n,len) * r
        b := sma(src,len) + a*stdev(src,len)    
        result := b
    if type=="PEMA"
        // Copyright (c) 2010-present, Bruno Pio
        // Copyright (c) 2019-present, Alex Orekhov (everget)
        // Pentuple Exponential Moving Average script may be freely distributed under the MIT license.
        ema1 = ema(src, len)
        ema2 = ema(ema1, len)
        ema3 = ema(ema2, len)
        ema4 = ema(ema3, len)
        ema5 = ema(ema4, len)
        ema6 = ema(ema5, len)
        ema7 = ema(ema6, len)
        ema8 = ema(ema7, len)
        pema = 8 * ema1 - 28 * ema2 + 56 * ema3 - 70 * ema4 + 56 * ema5 - 28 * ema6 + 8 * ema7 - ema8    
        result := pema
    if type=="HCF"
        output = 0.
        output := filter(src, nz(output[1],src), len)
        result := output
    if type=="TIF"
        b = 0.0
        a = rising(src,len) or falling(src,len) ? 1 : 0
        b := ema(a*src+(1-a)*nz(b[1],src),center)
        result := b
    if type=="MF"
        ts=0.,b=0.,c=0.,os=0.
        //----
        alpha = 2/(len+1)
        a = feedback ? z*src + (1-z)*nz(ts[1],src) : src
        //----
        b := a > alpha*a+(1-alpha)*nz(b[1],a) ? a : alpha*a+(1-alpha)*nz(b[1],a)
        c := a < alpha*a+(1-alpha)*nz(c[1],a) ? a : alpha*a+(1-alpha)*nz(c[1],a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = beta*b+(1-beta)*c
        lower = beta*c+(1-beta)*b 
        ts := os*upper+(1-os)*lower
        result := ts
    if type=="ARMA"
    //----
        ma = 0.
        mad = 0.
        //----
        src2 = zl ? src + change(src,len/2) : src
        ma := nz(mad[1],src2)
        d = cum(abs(src2[len] - ma))/bar_index * gamma
        mad := sma(sma(src2 > nz(mad[1],src2) + d ? src2 + d : src2 < nz(mad[1],src) - d ? src2 - d : nz(mad[1],src2),len),len)
        result := mad
    if type=="DAF"
        AC = zl ? 1 : 0
        out = 0.
        K = 0.
        //----
        src2 = src + (src - nz(out[1],src))
        out := nz(out[1],src2) + nz(K[1])*(src2 - nz(out[1],src2)) + AC*(nz(K[1])*(src2 - sma(src2,len)))
        K := abs(src2 - out)/(abs(src2 - out) + stdev(src2,len)*len)
        result := out
    if type=="WRMA"
        //----
        alpha = 2/(len+1)
        p1 = zl ? len/4 : 1
        p2 = zl ? len/4 : len/2
        //----
        a = 0.0
        b = 0.0
        A = 0.0
        B = 0.0
        a := nz(a[1]) + alpha*nz(A[1]) 
        b := nz(b[1]) + alpha*nz(B[1])
        y = ema(a + b,p1)
        A := src - y
        B := src - ema(y,p2)
        result := y
        //----
    if type=="RMA"
        ma = sma(src,len*3) + sma(src,len*2) - sma(src,len)
        result := ma
    if type=="RAF"
        altma = 0.0
        AR = 2*(highest(len) - lowest(len))
        BR = 2*(highest(len*2) - lowest(len*2))
        k1 = (1 - AR)/AR
        k2 = (1 - BR)/BR
        //
        alpha = k2/k1
        R1 = sqrt(highest(len))/4 * ((alpha - 1)/alpha) * (k2/(k2 + 1))
        R2 = sqrt(highest(len*2))/4 * (alpha - 1) * (k1/(k1 + 1))
        Factor = R2/R1 
        //
        AltK = fixnan(pow(Factor >= 1 ? 1 : Factor,sqrt(len)))*(1/len)
        altma := AltK*src+(1-AltK)*nz(altma[1],src)
        result := altma
    if type=="GF"
        ////////////////////////////////////////////////////////////////
        //Coefficients Table :
        //
        //MA : beta = 2/gamma = 0.5
        //EMA : beta = 3/gamma = 0.4
        //HMA = beta = 4/gamma = 0.85
        //LSMA : beta = 3.5/gamma = 0.9 
        //QLSMA : beta = 5.25/gamma = 1
        //JMA : beta = pow*2/gamma = 0.5
        //3 Poles Butterworth Filter : beta = 5.5/gamma = 0.5/zeta = 0
        //
        ////////////////////////////////////////////////////////////////
        b = 0.0
        d = 0.0
        p = len/beta
        a = src - nz(b[p],src)
        b := nz(b[1],src) + a/p*gamma
        c = b - nz(d[p],b)
        d := nz(d[1],src) + (zeta*a+(1-zeta)*c)/p*gamma
        result := d
    if type=="A2RMA"
        er = abs(change(src,len))/sum(abs(change(src)),len)
        //----
        ma = 0.
        d = cum(abs(src - nz(ma[1],src)))/bar_index * gamma
        ma := ama(er,ama(er,src > nz(ma[1],src) + d ? src + d : src < nz(ma[1],src) - d ? src - d : nz(ma[1],src)))
        //----
        result := ma
    if type=="EDSMA"
        zeros = src - nz(src[2])
        avgZeros = (zeros + zeros[1]) / 2
        
        // Ehlers Super Smoother Filter 
        ssf = ssfPoles == 2
             ? get2PoleSSF(avgZeros, ssfLength)
             : get3PoleSSF(avgZeros, ssfLength)
        
        // Rescale filter in terms of Standard Deviations
        stdev = stdev(ssf, len)
        scaledFilter = stdev != 0
             ? ssf / stdev
             : 0
        
        alpha = 5 * abs(scaledFilter) / len
        
        edsma = 0.0
        edsma := alpha * src + (1 - alpha) * nz(edsma[1])
        result :=  edsma
    result

//---parameters
calc = (close - open)
ma_value = ma(Mode, calc, PriceSmoothing)

///// Z SCORE CALCULATION
Whip_Lash = ma_value
xStdDev = stdev(Whip_Lash, zlength)
xMA = sma(Whip_Lash, zlength)
z2 = (Whip_Lash - xMA) / xStdDev

//=== ENHANCED SIGNALS WITH CLEAR COLORS ===

// LONG SIGNAL COLORS
long_th1_color = color.yellow
long_th2_color = #FFA500  // Orange
long_th3_color = color.red

// SHORT SIGNAL COLORS
short_th1_color = color.yellow
short_th2_color = #FFA500  // Orange
short_th3_color = color.blue

// Define conditions
// LONG CONDITIONS
LTA1 = z2 > (vq0_mid + vq0_th) and z2 <= (vq0_mid + vq0_th2)
LTA2 = z2 > (vq0_mid + vq0_th2) and z2 <= (vq0_mid + vq0_th3)
LTA3 = z2 > (vq0_mid + vq0_th3)

// SHORT CONDITIONS
STA1 = z2 < (vq0_mid - vq0_th) and z2 >= (vq0_mid - vq0_th2)
STA2 = z2 < (vq0_mid - vq0_th2) and z2 >= (vq0_mid - vq0_th3)
STA3 = z2 < (vq0_mid - vq0_th3)

// Price Action Change
PAL = (z2 > 0)
PAS = (z2 < 0)
chgPAL = PAL and not PAL[1]
chgPAS = PAS and not PAS[1]

// Alert conditions with improved messages
alertcondition(LTA1, title ="LONG Threshold 1 (+1.68)", message="LONG SIGNAL - Threshold 1 Breached (+1.68) {{ticker}}")
alertcondition(LTA2, title ="LONG Threshold 2 (+1.96)", message="LONG SIGNAL - Threshold 2 Breached (+1.96) {{ticker}}")
alertcondition(LTA3, title ="LONG Threshold 3 (+2.58)", message="LONG SIGNAL - EXTREME! Threshold 3 Breached (+2.58) {{ticker}}")
alertcondition(STA1, title ="SHORT Threshold 1 (-1.68)", message="SHORT SIGNAL - Threshold 1 Breached (-1.68) {{ticker}}")
alertcondition(STA2, title ="SHORT Threshold 2 (-1.96)", message="SHORT SIGNAL - Threshold 2 Breached (-1.96) {{ticker}}")
alertcondition(STA3, title ="SHORT Threshold 3 (-2.58)", message="SHORT SIGNAL - EXTREME! Threshold 3 Breached (-2.58) {{ticker}}")
alertcondition(chgPAL, title ="Price Action Change to LONG", message="Price Action Changed to LONG - Close Short Entries")
alertcondition(chgPAS, title = "Price Action Change to SHORT", message="Price Action Changed to SHORT - Close Long Entries")

// Determine histogram color based on signals
hist_color = 
     LTA1 ? long_th1_color :
     LTA2 ? long_th2_color :
     LTA3 ? long_th3_color :
     STA1 ? short_th1_color :
     STA2 ? short_th2_color :
     STA3 ? short_th3_color : color.gray

// Plot Z-Score with enhanced colors
plot(z2, title = "Z-Score Whiplash", color=hist_color, style=plot.style_histogram, linewidth=2, transp=0)

// === VISUAL SIGNALS ON CHART ===

// Background clouds for extreme signals
bgcolor(LTA3 ? color.new(long_th3_color, 80) : na, title="LONG EXTREME Cloud")
bgcolor(STA3 ? color.new(short_th3_color, 80) : na, title="SHORT EXTREME Cloud")

// Plot shapes for signals
plotshape(LTA1 and not LTA1[1], title="LONG Th1 Signal", style=shape.triangleup, location=location.bottom, color=long_th1_color, size=size.small)
plotshape(LTA2 and not LTA2[1], title="LONG Th2 Signal", style=shape.triangleup, location=location.bottom, color=long_th2_color, size=size.normal)
plotshape(LTA3 and not LTA3[1], title="LONG Th3 Signal", style=shape.triangleup, location=location.bottom, color=long_th3_color, size=size.large)

plotshape(STA1 and not STA1[1], title="SHORT Th1 Signal", style=shape.triangledown, location=location.top, color=short_th1_color, size=size.small)
plotshape(STA2 and not STA2[1], title="SHORT Th2 Signal", style=shape.triangledown, location=location.top, color=short_th2_color, size=size.normal)
plotshape(STA3 and not STA3[1], title="SHORT Th3 Signal", style=shape.triangledown, location=location.top, color=short_th3_color, size=size.large)

// === ADD LABELS FOR CURRENT SIGNAL ===
var label current_signal_label = na
if LTA1 or LTA2 or LTA3 or STA1 or STA2 or STA3
    string signal_text = ""
    color signal_color = color.white
    
    if LTA3
        signal_text := "LONG EXTREME (+2.58+)"
        signal_color := long_th3_color
    else if LTA2
        signal_text := "LONG STRONG (+1.96+)"
        signal_color := long_th2_color
    else if LTA1
        signal_text := "LONG WEAK (+1.68+)"
        signal_color := long_th1_color
    else if STA3
        signal_text := "SHORT EXTREME (-2.58-)"
        signal_color := short_th3_color
    else if STA2
        signal_text := "SHORT STRONG (-1.96-)"
        signal_color := short_th2_color
    else if STA1
        signal_text := "SHORT WEAK (-1.68-)"
        signal_color := short_th1_color
    
    current_signal_label := label.new(bar_index, na, signal_text, 
         color=color.new(signal_color, 90), textcolor=color.white, 
         style=label.style_label_center, yloc=yloc.price)

// Reference lines
hline(0, title = "Zero Line", color=color.white, linestyle=hline.style_solid, linewidth=1)

// LONG Threshold Lines
hline(vq0_th, title = "LONG Threshold 1 (+1.68)", color=long_th1_color, linestyle=hline.style_dashed, linewidth=1)
hline(vq0_th2, title = "LONG Threshold 2 (+1.96)", color=long_th2_color, linestyle=hline.style_dashed, linewidth=2)
hline(vq0_th3, title = "LONG Threshold 3 (+2.58)", color=long_th3_color, linestyle=hline.style_solid, linewidth=2)

// SHORT Threshold Lines
hline(-vq0_th, title = "SHORT Threshold 1 (-1.68)", color=short_th1_color, linestyle=hline.style_dashed, linewidth=1)
hline(-vq0_th2, title = "SHORT Threshold 2 (-1.96)", color=short_th2_color, linestyle=hline.style_dashed, linewidth=2)
hline(-vq0_th3, title = "SHORT Threshold 3 (-2.58)", color=short_th3_color, linestyle=hline.style_solid, linewidth=2)

// Fill between thresholds for better visualization
fill(hline(vq0_th), hline(vq0_th2), color=color.new(long_th1_color, 90), title="LONG Zone 1")
fill(hline(vq0_th2), hline(vq0_th3), color=color.new(long_th2_color, 90), title="LONG Zone 2")
fill(hline(-vq0_th), hline(-vq0_th2), color=color.new(short_th1_color, 90), title="SHORT Zone 1")
fill(hline(-vq0_th2), hline(-vq0_th3), color=color.new(short_th2_color, 90), title="SHORT Zone 2")

// === INFORMATION BOX - SIMPLIFIED VERSION ===
var table info_table = table.new(position.top_right, 2, 11, 
     bgcolor=color.new(color.gray, 80), 
     border_width=1, 
     border_color=color.white)

if barstate.islast
    // Header
    table.cell(info_table, 0, 0, "WHIPLASH SIGNALS", 
         text_color=color.yellow, bgcolor=color.navy)
    table.cell(info_table, 1, 0, "ACTION", 
         text_color=color.yellow, bgcolor=color.navy)
    
    // LONG SIGNALS section header
    table.cell(info_table, 0, 1, "LONG SIGNALS:", 
         text_color=color.white, bgcolor=color.new(color.green, 70))
    table.cell(info_table, 1, 1, "Z-Score >", 
         text_color=color.white, bgcolor=color.new(color.green, 70))
    
    // LONG signals
    table.cell(info_table, 0, 2, "  Weak (+1.68)", text_color=long_th1_color)
    table.cell(info_table, 1, 2, "BUY", text_color=long_th1_color)
    
    table.cell(info_table, 0, 3, "  Strong (+1.96)", text_color=long_th2_color)
    table.cell(info_table, 1, 3, "BUY", text_color=long_th2_color)
    
    table.cell(info_table, 0, 4, "  Extreme (+2.58)", text_color=long_th3_color)
    table.cell(info_table, 1, 4, "BUY", text_color=long_th3_color)
    
    // Empty row for separation
    table.cell(info_table, 0, 5, "", text_color=color.white)
    table.cell(info_table, 1, 5, "", text_color=color.white)
    
    // SHORT SIGNALS section header
    table.cell(info_table, 0, 6, "SHORT SIGNALS:", 
         text_color=color.white, bgcolor=color.new(color.red, 70))
    table.cell(info_table, 1, 6, "Z-Score <", 
         text_color=color.white, bgcolor=color.new(color.red, 70))
    
    // SHORT signals
    table.cell(info_table, 0, 7, "  Weak (-1.68)", text_color=short_th1_color)
    table.cell(info_table, 1, 7, "SELL", text_color=short_th1_color)
    
    table.cell(info_table, 0, 8, "  Strong (-1.96)", text_color=short_th2_color)
    table.cell(info_table, 1, 8, "SELL", text_color=short_th2_color)
    
    table.cell(info_table, 0, 9, "  Extreme (-2.58)", text_color=short_th3_color)
    table.cell(info_table, 1, 9, "SELL", text_color=short_th3_color)
    
    // Current Z-Score
    table.cell(info_table, 0, 10, "Current Z-Score:", 
         text_color=color.white, bgcolor=color.new(color.purple, 70))
    table.cell(info_table, 1, 10, tostring(z2, "#.##"), 
         text_color=color.white, bgcolor=color.new(color.purple, 70))